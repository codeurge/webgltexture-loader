{"version":3,"sources":["../src/drawNDArrayTexture.js"],"names":["Buffer","global","isBuffer","b","isPacked","shape","stride","length","convertFloatToUint8","out","inp","ops","muls","gl","texture","array","floatSupported","dtype","slice","maxSize","getParameter","MAX_TEXTURE_SIZE","Error","packed","type","FLOAT","UNSIGNED_BYTE","format","LUMINANCE","data","offset","ALPHA","LUMINANCE_ALPHA","RGB","RGBA","buffer","buf_store","size","pool","malloc","buf_array","assign","subarray","texImage2D","TEXTURE_2D","free"],"mappings":"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","file":"drawNDArrayTexture.js","sourcesContent":["//@flow\nimport type { NDArray } from \"ndarray\";\nimport ndarray from \"ndarray\";\nimport ops from \"ndarray-ops\";\nimport pool from \"typedarray-pool\";\n\nif (typeof Buffer === \"undefined\") {\n  global.Buffer = class Buffer {\n    // mock shim so pool don't crash..\n    static isBuffer = b => b instanceof Buffer;\n  };\n}\n\n// code is partly taken from https://github.com/stackgl/gl-texture2d/blob/master/texture.js\n\nfunction isPacked(shape, stride) {\n  if (shape.length === 3) {\n    return (\n      stride[2] === 1 &&\n      stride[1] === shape[0] * shape[2] &&\n      stride[0] === shape[2]\n    );\n  }\n  return stride[0] === 1 && stride[1] === shape[0];\n}\n\nfunction convertFloatToUint8(out, inp) {\n  ops.muls(out, inp, 255.0);\n}\n\nexport default (\n  gl: WebGLRenderingContext,\n  texture: WebGLTexture,\n  array: NDArray,\n  floatSupported: boolean\n) => {\n  let dtype = array.dtype;\n  let shape = array.shape.slice();\n  let maxSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);\n  if (\n    shape[0] < 0 ||\n    shape[0] > maxSize ||\n    shape[1] < 0 ||\n    shape[1] > maxSize\n  ) {\n    throw new Error(\"gl-react: Invalid texture size\");\n  }\n  let packed = isPacked(shape, array.stride.slice());\n  let type = 0;\n  if (dtype === \"float32\") {\n    type = gl.FLOAT;\n  } else if (dtype === \"float64\") {\n    type = gl.FLOAT;\n    packed = false;\n    dtype = \"float32\";\n  } else if (dtype === \"uint8\") {\n    type = gl.UNSIGNED_BYTE;\n  } else {\n    type = gl.UNSIGNED_BYTE;\n    packed = false;\n    dtype = \"uint8\";\n  }\n  let format = 0;\n  if (shape.length === 2) {\n    format = gl.LUMINANCE;\n    shape = [shape[0], shape[1], 1];\n    array = ndarray(\n      array.data,\n      shape,\n      [array.stride[0], array.stride[1], 1],\n      array.offset\n    );\n  } else if (shape.length === 3) {\n    if (shape[2] === 1) {\n      format = gl.ALPHA;\n    } else if (shape[2] === 2) {\n      format = gl.LUMINANCE_ALPHA;\n    } else if (shape[2] === 3) {\n      format = gl.RGB;\n    } else if (shape[2] === 4) {\n      format = gl.RGBA;\n    } else {\n      throw new Error(\"gl-texture2d: Invalid shape for pixel coords\");\n    }\n  } else {\n    throw new Error(\"gl-texture2d: Invalid shape for texture\");\n  }\n  if (type === gl.FLOAT && !floatSupported) {\n    type = gl.UNSIGNED_BYTE;\n    packed = false;\n  }\n  let buffer, buf_store;\n  let size = array.size;\n  if (!packed) {\n    let stride = [shape[2], shape[2] * shape[0], 1];\n    buf_store = pool.malloc(size, dtype);\n    let buf_array = ndarray(buf_store, shape, stride, 0);\n    if (\n      (dtype === \"float32\" || dtype === \"float64\") &&\n      type === gl.UNSIGNED_BYTE\n    ) {\n      convertFloatToUint8(buf_array, array);\n    } else {\n      ops.assign(buf_array, array);\n    }\n    buffer = buf_store.subarray(0, size);\n  } else if (array.offset === 0 && array.data.length === size) {\n    buffer = array.data;\n  } else {\n    buffer = array.data.subarray(array.offset, array.offset + size);\n  }\n  gl.texImage2D(\n    gl.TEXTURE_2D,\n    0,\n    format,\n    shape[0],\n    shape[1],\n    0,\n    format,\n    type,\n    buffer\n  );\n  if (buf_store) {\n    pool.free(buf_store);\n  }\n};\n"]}